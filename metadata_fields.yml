# Metadata fields specification (see also metadata_template.csv).
# 
# <column_name>:
#   dtype:    The data type. Supported values are: null (the default when missing), int,
#             float, str, bool, datetime. Provide a list of values (all the same dtype)
#             for categorical data, i.e. when the column can only take on one of the
#             given values. If non-null, the data type will be used for data validation
#   help:     The field help (optional), used to provide documentation

# Distance related CSV fields:

#azimuth:
#  dtype: float
#  help: azimuth (deg)
id:
  dtype: int
  help: >- 
    the unique record id, as sequential integer usually inferred from the source metadata
epicentral_distance:
  dtype: float
  help: epicentral distance (aka repi, in km)
rupture_distance:
  dtype: float
  help: rupture_distance (aka rrup, in km).
joyner_boore_distance:
  dtype: float
  help: Joyner-Boore distance (aka rjb, in km)
hypocentral_distance:
  dtype: float
  help: hypocentral distance (aka rhypo, in km)
fault_normal_distance:
  dtype: float
  help: Horizontal distance (in km) from the top of the rupture measured perpendicular to strike (aka Rx, in km)
fault_parallel_distance:
  dtype: float
  help: Horizontal distance (in km) from the top of the rupture measured parallel to strike (aka ry0, in km)

#r_volc:
#  dtype: float
#  help: Distance through volcanic zone (km). When missing, it defaults to 0

# Rupture related CSV fields:

event_id:
  dtype: str
  help: >-
    The ID of the seismic event, used to determine when two records
    originate from the same earthquake. IDs do not have a specific data type but
    are usually either numeric integers (recommended) or string of text (discouraged,
    especially for flatfiles with many distinct event IDs)
origin_time:
  dtype: datetime
  help: the event origin time (as ISO formatted string, e.g. 2006-03-31T00:12:24)
event_latitude:
  dtype: float
  help: Event latitude (hypocenter latitude, in deg) in [-90, 90]
event_longitude:
  dtype: float
  help: Event longitude (hypocenter longitude, in deg) in [-180, 180]
magnitude:
  dtype: float
  help: event magnitude
magnitude_type:
  dtype: ["ML", "mb", "Ms", 'Mw', "MJ", "MD", "Md", "MV", "Mv"]
  help: magnitude type. For MJ, MD, Md, MV, Mv, see https://www.data.jma.go.jp/eqev/data/bulletin/catalog/notes_e.html
event_depth:
  dtype: float
  help: event depth (hypocentral depth, in km)
depth_to_top_of_fault_rupture:
  dtype: float
  help: Top of Rupture Depth (aka ztor, in km). Must be >=0
fault_rupture_width:
  dtype: float
  ">=": 0
  help: >-
    Down-dip width of the rupture (km), >=0. Hint: missing data might be derived from 
    the record magnitude using a Magnitude-Scaling Relationship defined for PEER PSHA 
    test cases, and assuming an aspect ratio of 1
dip:
  dtype: float
  help: >-
    the angle of the fault relative to the horizontal (deg) in [0, 90]. 
    If the actual fault plane could not be determined in the source metadata, the same
    value for the conjugate plane is stored in dip2. Otherwise, dip2 is NaN or None
dip2:
  dtype: float
  help: The dip for one of the possible fault planes, or N/A (see dip help for details)
rake:
  dtype: float
  help: >-
    the direction the hanging wall moves, relative to the fault strike (deg) in 
    [-180, 180]. If the actual fault plane could not be available in the source metadata, 
    the same value for the conjugate plane is stored in rake2. Otherwise, rake2 is NaN or 
    None
rake2:
  dtype: float
  help: The dip for one of the possible fault planes, or N/A (see dip help for details)
strike:
  dtype: float
  help: >- 
    Strike angle in [0, 360] of the fault plane used to approximate the causative fault 
    surface. If the actual fault plane could not be available in the source metadata, the
    same value for the conjugate plane is stored in strike2. Otherwise, strike2 is NaN or 
    None
strike2:
  dtype: float
  help: The dip for one of the possible fault planes, or N/A (see dip help for details)
fault_type:
  dtype: [0,1,2,3,4]
  help: >-
    Mechanism based on Rake Angle (Style of Faulting, sof). 0: Strike-slip (rake angles:
    -180 < Rake < -150, -30 < Rake < 30, 150 < Rake < 180). 1: Normal (-120 < Rake < -60).
    2: Reverse (60 < Rake < 120). 3: Reverse-Oblique (30 < Rake < 60, 120 < Rake < 150),
    4: Normal-Oblique (-150 < Rake < -120, -60 < Rake < -30)

# Site-related CSV fields:

station_id:
  dtype: str
  help: >-
    The unique ID of the seismic station. If missing, an id is inferred from
    the station spatial coordinates (latitude, longitude), which must all be present.
    In general, you can infer the id from the tuple (network_code, station_code)
    or create your own, as long as it holds: same id <=> same station. IDs should
    be preferably of type integer for performance reasons
z1:
  dtype: float
  help: >-
    depth of the layer where seismic waves start to propagate with a speed above 1.0
    km/sec, in meters. Missing data (e.g., empty cell, NaN, column not provided) will be
    derived from the vs30 (if present) using the Chiou & Youngs (2014) California
    model
z2pt5:
  dtype: float
  help: >-
    depth of the layer where seismic waves start to propagate with a speed above
    2.5 km/sec, in km. Missing data (e.g., empty cell, NaN, column not provided) will
    be derived from the vs30 (if present) using the Campbell & Bozorgnia (2014) model
vs30:
  dtype: float
  help: Average shear wave velocity in the top 30 m, in m/s (>=0)
vs30measured:
  dtype: bool
  help: whether or not the Vs30 is measured (default true)
  default: true
#backarc:
#  dtype: bool
#  help: >-
#    whether or not the site is in the subduction backarc. When missing (or false, the
#    default) the site is assumed to be unknown or in the subduction forearc
#  default: false
station_latitude:
  dtype: float
  help: station latitude (deg), in [-90, 90]
station_longitude:
  dtype: float
  help: station longitude (deg), in [-180, 180]

#xvf:
#  dtype: float
#  help: distance to the volcanic front (km)

#fpeak:
#  dtype: float
#  help: >-
#    Frequency that corresponds to the peak of the horizontal to vertical
#    spectral ratio (Hz), >=0

region:
  dtype: [0, 1, 2, 3, 4, 5]
  help: >-
    The ESHM2020 attenuation cluster region to which the site belongs
    (https://doi.org/10.1007/s10518-020-00899-9). 0 (default when missing): unknown,
    1: average / slower, 2: average / faster, 3: fast, 4: average, 5: very slow
#geology:
#  dtype: ["CENOZOIC", "HOLOCENE", "JURASSIC-TRIASSIC", "CRETACEOUS", "PALEOZOIC",
#          "PLEISTOCENE", "PRECAMBRIAN", "UNKNOWN"]
#  help: geological classification of the site. Default UNKNOWN
#slope:
#  dtype: float
#  help: The local slope of the station, >0

# Time histories-related CSV fields:

#sensor_type:
#  dtype: ['A', 'V', 'D']
#  help: >-
#    the recording type. Acceleration, Velocity or Displacement. Time series
#    units must be m /s**2, m/ s or m accordingly

#fpath:
#  dtype: str
#  help: >-
#    the waveform(s) path, relative to the metadata.csv directory.
#    The file is an hdf5 file which stores a maximum of 3 h5py.Datasets object named
#    "h1", "h2" and "v" (first and second horizontal component, and vertical). At least
#    one component must be present not all 3 are mandatory, so code must check if they
#    exist
#fpath_h1:
#  dtype: str
#  help: the waveform path, relative to the metadata.csv directory, of the 1st horizontal component
#fpath_h2:
#  dtype: str
#  help: the waveform path, relative to the metadata.csv directory, of the 2nd horizontal component
#fpath_v:
#  dtype: str
#  help: the waveform path, relative to the metadata.csv directory, of the 3rd horizontal component
filter_type:
  dtype: ["O", "A", "C"]
  help: >- 
    Type of filter used to remove noise at long and short periods. 
    O: Ormsby, A: Acausal Butterworth, C Causal butterworth
npass:
  dtype: int
  help: Number of passes of filter. ) when not applicable / not available
  default: 0
nroll:
  dtype: float
  help: The `nroll` parameter of the Butterworth filter. 0 when not applicable / not available
lower_cutoff_frequency_h1:
  dtype: float
  help: Corner frequency of the high-pass filter of component H1, in Hz
lower_cutoff_frequency_h2:
  dtype: float
  help: Corner frequency of the high-pass filter of component H2, in Hz
upper_cutoff_frequency_h1:
  dtype: float
  help: Corner frequency of the low-pass filter of component H1, in Hz
upper_cutoff_frequency_h2:
  dtype: float
  help: Corner frequency of the low-pass filter of component H2, in Hz
lowest_usable_frequency_h1:
  dtype: float
  help: Lowest usable frequency of component H1, in Hz usually as ratio of hp_h1
lowest_usable_frequency_h2:
  dtype: float
  help: Lowest usable frequency of component H2, in Hz usually as ratio of hp_h1
available_components:
  dtype: ['H', 'HH', 'HV', 'V', 'HHV']
  help: >-
    The available time histories for this recording: H: only one (horizontal 
    component), HH: the two horizontal components, HV: one horizontal and one vertical,
    V: only vertical, HHV: all three components (2 horizontal, and the vertical).
sampling_rate:
  dtype: int
  help: >- 
    The sampling rate. If non-zero, it is the sampling rate of all available
    components (h1, h2, v). If zero, it denotes some error (sampling rate not equal among 
    components, or non-integer)
start_time:
  dtype: datetime
  help: start time of the time histories (h1, h2, v). Assumes all components start time is the same
p_wave_arrival_time:
  dtype: float
  help: Theoretical P-wave arrival time
s_wave_arrival_time:
  dtype: float
  help: Theoretical S-wave arrival time
PGA:
  dtype: float
  help: >-
    PGA. If available it is the PGA computed at RotD50. If the two horizontal 
    components are available, it is their geometric mean. This datum is retrieved from
    the source catalog, not computed directly from the data (consistency between the two
    entities is performed, when possible)
